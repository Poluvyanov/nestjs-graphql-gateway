import { buildFederatedSchema, printSchema } from '@apollo/federation';
import { Injectable } from '@nestjs/common';
import { loadPackage } from '@nestjs/common/utils/load-package.util';
import { ResolversExplorerService } from '@nestjs/graphql/dist/services/resolvers-explorer.service';
import { ScalarsExplorerService } from '@nestjs/graphql/dist/services/scalars-explorer.service';
import { DelegatesExplorerService } from '@nestjs/graphql/dist/services/delegates-explorer.service';
import { GraphQLAstExplorer } from '@nestjs/graphql/dist/graphql-ast.explorer';
import { extend } from '@nestjs/graphql/dist/utils/extend.util';
import { removeTempField } from '@nestjs/graphql/dist/utils/remove-temp.util';
import { GqlModuleOptions } from '@nestjs/graphql';
import { existsSync, lstatSync, readFileSync } from 'fs';
import { forEach, isEmpty } from 'lodash';
import gql from 'graphql-tag';
import { GraphQLObjectType, GraphQLSchema, GraphQLSchemaConfig } from 'graphql';
import { FedGraphQLSchemaBuilder } from './graphql-schema-builder';
import { FedGqlModuleOptions } from './interfaces';
import { ReferencesExplorerService } from './services';

@Injectable()
export class GraphqlDistributedFactory {
  constructor(
    private readonly resolversExplorerService: ResolversExplorerService,
    private readonly delegatesExplorerService: DelegatesExplorerService,
    private readonly referencesExplorerService: ReferencesExplorerService,
    private readonly scalarsExplorerService: ScalarsExplorerService,
    private readonly graphqlAstExplorer: GraphQLAstExplorer,
    private readonly gqlSchemaBuilder: FedGraphQLSchemaBuilder,
  ) {}

  // @ts-ignore
  public async mergeOptions(options: FedGqlModuleOptions = {}): Promise<GqlModuleOptions> {
    const resolvers = this.extendResolvers([
      this.resolversExplorerService.explore(),
      this.scalarsExplorerService.explore(),
      this.referencesExplorerService.explore(),
    ]);

    if (options.autoSchemaFile) {

      const autoGeneratedSchema: GraphQLSchema = await this.gqlSchemaBuilder.build(
        options.autoSchemaFile,
        options.buildSchemaOptions,
        this.resolversExplorerService.getAllCtors(),
      );

      const federatedSchemaGen = buildFederatedSchema({
        typeDefs: gql(printSchema(autoGeneratedSchema)),
        resolvers: extend(resolvers, options.resolvers),
      });

      let schema = federatedSchemaGen;
      const autoGeneratedSchemaConfig = federatedSchemaGen.toConfig();

      const schemaConfig = this.overrideOrExtendResolvers(
        schema.toConfig(),
        autoGeneratedSchemaConfig,
      );

      schema = new GraphQLSchema(schemaConfig);

      removeTempField(schema);

      return {
        ...options,
        typeDefs: undefined,
        schema,
      };

    }

    const federatedSchema = buildFederatedSchema([
      {
        typeDefs: gql`${options.typeDefs}`,
        resolvers,
      },
    ]);

    removeTempField(federatedSchema);
    return {
      ...options,
      typeDefs: undefined,
      schema: federatedSchema,
    };
  }

  private extendResolvers(resolvers: any[]) {
    // @ts-ignore
    return resolvers.reduce((prev, curr) => extend(prev, curr), {});
  }

  private loadBuildSchemaFactory(): (...args: any[]) => GraphQLSchema {
    const { buildSchema } = loadPackage('type-graphql', 'SchemaBuilder', () =>
      require('type-graphql'),
    );
    return buildSchema;
  }

  overrideOrExtendResolvers(
    executableSchemaConfig: GraphQLSchemaConfig,
    autoGeneratedSchemaConfig: GraphQLSchemaConfig,
  ): GraphQLSchemaConfig {
    const schemaConfig = autoGeneratedSchemaConfig;
    const rootResolverKeys: Array<'mutation' | 'query' | 'subscription'> = [
      'mutation',
      'query',
      'subscription',
    ];

    rootResolverKeys
      .filter(key => executableSchemaConfig[key] && schemaConfig[key])
      .forEach(key => {
        const executableSchemaFields = executableSchemaConfig[key].getFields();
        const schemaFields = schemaConfig[key].getFields();

        forEach(executableSchemaFields, (value, resolverName) => {
          if (schemaFields[resolverName]) {
            schemaFields[resolverName].resolve =
              executableSchemaFields[resolverName].resolve;

            if (schemaFields[resolverName].subscribe) {
              schemaFields[resolverName].subscribe =
                executableSchemaFields[resolverName].subscribe;
            }
          } else {
            schemaFields[resolverName] = executableSchemaFields[resolverName];
          }
        });
      });

    const getAutoGeneratedTypeByName = (name: string): GraphQLObjectType =>
      schemaConfig.types.find(type => type.name === name) as GraphQLObjectType;

    executableSchemaConfig.types
      .filter(type => type instanceof GraphQLObjectType)
      .forEach((type: GraphQLObjectType) => {
        const fields = type.getFields();
        forEach(fields, (value, key) => {
          if (!value.resolve) {
            return;
          }
          const autoGeneratedType = getAutoGeneratedTypeByName(type.name);
          if (!autoGeneratedType) {
            return;
          }
          const field = autoGeneratedType.getFields()[key];
          // tslint:disable-next-line:no-unused-expression
          field && (field.resolve = value.resolve);
        });
      });

    return schemaConfig;
  }

  createDelegates(): (mergeInfo: any) => any {
    return this.delegatesExplorerService.explore();
  }

  async generateDefinitions(
    typeDefs: string | string[],
    options: GqlModuleOptions,
  ) {
    if (isEmpty(typeDefs) || !options.definitions) {
      return;
    }
    const tsFile = await this.graphqlAstExplorer.explore(
      gql`
        ${typeDefs}
      `,
      options.definitions.path,
      options.definitions.outputAs,
    );
    if (
      !existsSync(options.definitions.path) ||
      !lstatSync(options.definitions.path).isFile() ||
      readFileSync(options.definitions.path, 'utf8') !== tsFile.getFullText()
    ) {
      await tsFile.save();
    }
  }
}
